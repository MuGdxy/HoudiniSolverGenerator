/*
Generated By HoudiniSolverGenerator
Author: MuGdxy https://github.com/MuGdxy
*/


#pragma once
#include <memory>
#include <SIM/SIM_SingleSolver.h>
#include <SIM/SIM_OptionsUser.h>
#include <SIM/SIM_Engine.h>
#include <GU/GU_PrimPoly.h>
#include <PRM/PRM_Include.h>
#include <SIM/SIM_DopDescription.h>
#include <SIM/SIM_GeometryCopy.h>
#include <SIM/SIM_DataFilter.h>

#define SIM_NAME_SOURCEOBJECTS "sourceobjects"

class SIM_ObjectArray;
class SIM_GeometryCopy;




/***********************************************
	Implement your own solver in such a class!
************************************************/
class _EXAMPLE_SOLVER_ {};
// or just
// using _EXAMPLE_SOLVER_ = YOUR_CORE_SOLVER;

class SIM__EXAMPLE_SOLVER_;

struct SolverArgs
{
	SIM__EXAMPLE_SOLVER_& solverObject;
	SIM_Engine& engine;
	SIM_Object& object;
	SIM_ObjectArray& objectArray;
	const SIM_Time& timestep;

	SolverArgs(SIM__EXAMPLE_SOLVER_& solverObject, SIM_Engine& engine, SIM_Object& object, SIM_ObjectArray& objectArray, const SIM_Time& timestep)
		: solverObject(solverObject)
		, engine(engine)
		, object(object)
		, objectArray(objectArray)
		, timestep(timestep)
		{
			
		}
};

class _EXAMPLE_SOLVER_Wrapper
{
	std::unique_ptr<_EXAMPLE_SOLVER_> solver;

public:
	SIM_Solver::SIM_Result Init(SolverArgs data);
	SIM_Solver::SIM_Result Solve(SolverArgs data);
};

// This class implemented a computational fluid dynamics solver.
class SIM__EXAMPLE_SOLVER_ : public SIM_SingleSolver, public SIM_OptionsUser
{
protected:
	explicit SIM__EXAMPLE_SOLVER_(const SIM_DataFactory* factory)
		: BaseClass(factory)
		, SIM_OptionsUser(this)
	{
	};

	~SIM__EXAMPLE_SOLVER_() override {};

	SIM_Result solveSingleObjectSubclass(SIM_Engine& engine,
		SIM_Object& object,
		SIM_ObjectArray& objectArray,
		const SIM_Time& timestep,
		bool             newobject) override
	{
		auto build = false;

		SolverArgs args(*this, engine, object, objectArray, timestep);
		if (!wrapper)
		{
			build = true;
			wrapper = std::make_shared<_EXAMPLE_SOLVER_Wrapper>();
		}
		// start simulation
		if (newobject || build)
		{
			return wrapper->Init(args);
		}
		else
		{
			return wrapper->Solve(args);
		}
		return SIM_SOLVER_SUCCESS;
	}

	void makeEqualSubclass(const SIM_Data* src)
	{
		BaseClass::makeEqualSubclass(src);
		const auto* s = SIM_DATA_CASTCONST(src, SIM__EXAMPLE_SOLVER_);
		// do not share if the solver is being copied from another dopnet
		if (s && getOwnerNetwork() == s->getOwnerNetwork())
		{
			if (!s->wrapper)
				s->wrapper = std::make_shared<_EXAMPLE_SOLVER_Wrapper>();
			this->wrapper = s->wrapper;
		}
		else
			wrapper.reset();
	}

private:
	mutable std::shared_ptr<_EXAMPLE_SOLVER_Wrapper> wrapper = nullptr;

	static const SIM_DopDescription* getDopDescription()
	{
		static PRM_Template theTemplates[] = { PRM_Template() };

		static SIM_DopDescription theDopDescription(
			true, "_EXAMPLE_SOLVER_", "_EXAMPLE_SOLVER_", SIM_SOLVER_DATANAME, classname(), theTemplates);

		return &theDopDescription;
	}

	DECLARE_STANDARD_GETCASTTOTYPE();
	DECLARE_DATAFACTORY(SIM__EXAMPLE_SOLVER_, SIM_SingleSolver, "_EXAMPLE_SOLVER_", getDopDescription());
};
